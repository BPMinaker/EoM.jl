    ## Copyright (C) 2020, Bruce Minaker
    ## summarize.jl is free software; you can redistribute it and/or modify it
    ## under the terms of the GNU General Public License as published by
    ## the Free Software Foundation; either version 2, or (at your option)
    ## any later version.
    ##
    ## summarize.jl is distributed in the hope that it will be useful, but
    ## WITHOUT ANY WARRANTY; without even the implied warranty of
    ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    ## General Public License for more details at www.gnu.org/copyleft/gpl.html.
    ##
    ##--------------------------------------------------------------------
    using Plots.Measures
function summarize(
    system::mbd_system,
    results::EoM.analysis,
    verbose::Bool = false;
    plots = [],
    ss = ones(Int64, length(system.sensors), length(system.actuators)),
    bode = ones(Int64, length(system.sensors), length(system.actuators)),
    vpt_name = ["u" "Speed" "m/s"],
    format = :screen,
    folder::String = "output",
    filename::String = system.name,
)
    summarize([system], 0, [results], verbose; plots, ss, bode, vpt_name, format, folder, filename)
end

function summarize(
    systems::Vector{mbd_system},
    vpts,
    results::Vector{EoM.analysis},
    verbose::Bool = false;
    plots = [],
    ss = ones(Int64, length(systems[1].sensors), length(systems[1].actuators)),
    bode = ones(Int64, length(systems[1].sensors), length(systems[1].actuators)),
    vpt_name = ["u" "Speed" "m/s"],
    format = :screen,
    folder::String = "output",
    filename::String = systems[1].name,
)

#    if format == :screen
#        gr()
#        display(plot(1,1; label = "", size = (50, 50)))
#    end
    plotly()

    verbose && println("Printing summary of the analysis of: $(systems[1].name)...")

    noeigs = false

    if format == :html

        # set up the paths
        dirs = setup(folder = folder, data = filename)
        dir_date = dirs[1]
        dir_time = dirs[2]
        dir_data = joinpath(dir_date, dir_time)

        # default html start and end text
        str_open = "<!doctype html><html lang=\"en\" ><head>\n    <title>EoM Analysis results</title>\n    <meta charset=\"utf-8\">\n    <meta name=\"description\" content=\"EoM Analysis result\">\n    <meta name=\"author\" content=\"automatically generated by EoM\">\n    <style>\n    table {\n    border-collapse: collapse;\n    }\n    td, th {\n    border: 1px solid #dddddd;\n    text-align: center;\n    padding: 8px;\n    }\n    tr:nth-child(even) {\n    background-color: #dddddd;\n    }\n    </style>\n</head>\n<body>\n"

        str_close = "</body>\n</html>"

        # open the base html file to write, and start filling it
        output_f = open(joinpath(dir_date, filename * ".html"), "w")
        println(output_f, str_open)
        println(output_f, "<img src=\"figures/eom_logo.png\" alt=\"Icon\" style=\"width:200px;\">")
        println(output_f, "<h1>Analysis results</h1>")
        println(output_f, "<p>Here are the results of the analysis of: $(systems[1].name)</p>")
    end

    # get names of inputs and outputs
    input_names = getfield.(systems[1].actuators, :name)
    input_units = getfield.(systems[1].actuators, :units)
    output_names = getfield.(systems[1].sensors, :name)
    output_units = getfield.(systems[1].sensors, :units)

    # get number of ins, outs, and number of vpts (velocity points)
    nin = length(input_names)
    nout = length(output_names)
    nvpts = length(vpts)

    # if there are too many inputs and outputs, skip
    if nin * nout > 0 && nin * nout < 16 && length(ss) > 0
        labels = []
        gain = []
        # loop over outputs and inputs and vpts
        for i in 1:nout
            for j in 1:nin
                # n = (i - 1) * nin + j
                #if findnext(ss .== n, 1) !== nothing
                if ss[i, j] == 1
                    x = zeros(nvpts)
                    for k in 1:nvpts
                        x[k] = my_round(results[k].ss_resp[i, j])
                    end
                    push!(gain, x[1])

                    if output_units[i] == input_units[j]
                        str_u = ""
                    elseif contains(output_units[i], input_units[j])
                        if contains(output_units[i], "/")
                            str_u = " [$(replace(output_units[i], input_units[j] => "1"))]"
                        else
                            str_u = " [$(replace(output_units[i], input_units[j] => ""))]"
                        end
                    else
                        str_u = " [$(output_units[i])/$(input_units[j])]"
                    end
                    lb = "$(output_names[i])/$(input_names[j])$str_u"
                    push!(labels, lb)
                    # if many vpts, make plot vs velocity
                    if nvpts > 1
                        p = plot(
                            vpts,
                            x;
                            lw = 2,
                            xlabel = vpt_name[2] * " [" * vpt_name[3] * "]",
                            ylabel = lb,
                            label = "",
                            size = (600, 300),
                        )
                        if format == :html
                            path = joinpath(dir_data, "sstf_$(i)_$(j).html")
                            savefig(p, path)
                            f = open(path, "r")
                            println(output_f, read(f, String))
                            close(f)
                        else
                            display(p)
                        end
                    end
                end
            end
        end

        # if only one vpt, make table of the gains
        if nvpts == 1
            header = ["Output/Input", "Gain"]
            if format == :html
                println(output_f, "<h2>Steady state gains</h2>")
                str = pretty_table(String,[labels my_round.(gain)]; header, backend = :html, standalone = false)
                println(output_f, str)
    
                path = joinpath(dir_data, "sstf.html")
                temp = open(path, "w")
                println(temp, str_open, str, str_close)
                close(temp)
            else
                println("Steady state gains:")
                pretty_table([labels my_round.(gain)]; header)
            end
        end
    end

    if !noeigs
        # get eigenvalues
        l = length.(getfield.(results, :e_val))
        m = maximum(l)
        s = zeros(m, nvpts) * 1im
        for i in 1:nvpts
            s[1:l[i], i] = results[i].e_val
        end

        # for one velocity, chart of calcs from eigenvalues, otherwise plot eigenvalues
        if nvpts == 1
            omega = results[1].omega_n
            zeta = results[1].zeta
            tau = results[1].tau
            lambda = results[1].lambda
            header = ["No.", "σ±ωi [1/s]", "ω_n [Hz]", "ζ", "τ [s]", "λ [s]"]

            if format == :html
                println(output_f, "<h2>Eigenvalues of minimal system</h2>")
                str=pretty_table(String,[1:1:l[1] my_round.([s omega zeta tau lambda])]; header, backend = :html, standalone = false)
                println(output_f, str)

                path = joinpath(dir_data, "eigen.html")
                temp = open(path, "w")
                println(temp, str_open, str, str_close)
                close(temp)
            else
                println("Eigenvalues of minimal system:")
                pretty_table([1:1:l[1] my_round.([s omega zeta tau lambda])]; header)
            end

        else

            # plot real and imaginary seperately
            sr = real.(s)
            si = imag.(s)

            # eliminate all zero rows
            tr = []
            for i in 1:size(sr, 1)
                if any(sr[i, :] .!= 0)
                    push!(tr, i)
                end
            end
            sr = sr[tr, :]
            tr = []
            for i in 1:size(si, 1)
                if any(si[i, :] .!= 0)
                    push!(tr, i)
                end
            end
            si = si[tr, :]

            # don't plot zeros - but can't have entire row of NaN
            sr[sr.==0] .= NaN
            si[si.==0] .= NaN

            seriestype = :scatter
            ms = 3
            p = plot(;
                xlabel = vpt_name[2] * " [" * vpt_name[3] * "]",
                ylabel = "Eigenvalue [1/s]",
                size = (600, 300),
            )

            rr = vec(sr')
            mc = RGB(0 / 255, 154 / 255, 250 / 255)
            label = "Real"
            u = size(sr, 1)
            vv = vcat(fill(vpts, u)...)
            if length(rr) > 0
                plot!(p, vv, rr; seriestype, mc, ms, label)
            end
            rr = vec(si')
            mc = RGB(227 / 255, 111 / 255, 71 / 255)
            label = "Imaginary"
            u = size(si, 1)
            vv = vcat(fill(vpts, u)...)
            if length(rr) > 0
                plot!(p, vv, rr; seriestype, mc, ms, label)
            end

            if format == :html
                println(output_f, "<h2>Eigenvalue plots</h2>")
                path = joinpath(dir_data, "eigen.html")
                savefig(p, path)
                f = open(path, "r")
                println(output_f, read(f, String))
                close(f)
            else
                display(p)
            end

            label = ""

            omega = treat(getfield.(results, :omega_n))
            mc = RGB(0 / 255, 154 / 255, 250 / 255)
            if size(omega, 2) > 0
                po = plot(
                    vpts,
                    omega;
                    seriestype,
                    mc,
                    ms,
                    label,
                    xlabel = vpt_name[2] * " [" * vpt_name[3] * "]",
                    ylabel = "Natural frequency [Hz]",
                    ylims = (0, Inf),
                    size = (600, 300),
                )
                if format == :html
                    path = joinpath(dir_data, "omega.html")
                    savefig(po, path)
                    f = open(path, "r")
                    println(output_f, read(f, String))
                    close(f)
                else
                    display(po)
                end
            end

            zeta = treat(getfield.(results, :zeta))
            mc = RGB(0 / 255, 154 / 255, 250 / 255)
            if size(zeta, 2) > 0
                pz = plot(
                    vpts,
                    zeta;
                    seriestype,
                    mc,
                    ms,
                    label,
                    xlabel = vpt_name[2] * " [" * vpt_name[3] * "]",
                    ylabel = "Damping ratio",
                    size = (600, 300),
                )
                if format == :html
                    path = joinpath(dir_data, "zeta.html")
                    savefig(pz, path)
                    f = open(path, "r")
                    println(output_f, read(f, String))
                    close(f)
                else
                    display(pz)
                end
            end

            tau = treat(getfield.(results, :tau))
            mc = RGB(0 / 255, 154 / 255, 250 / 255)
            if size(tau, 2) > 0
                pt = plot(
                    vpts,
                    tau;
                    seriestype,
                    mc,
                    ms,
                    label,
                    xlabel = vpt_name[2] * " [" * vpt_name[3] * "]",
                    ylabel = "Time constant [s]",
                    size = (600, 300),
                )
                if format == :html
                    path = joinpath(dir_data, "tau.html")
                    savefig(pt, path)
                    f = open(path, "r")
                    println(output_f, read(f, String))
                    close(f)
                else
                    display(pt)
                end
            end

            lambda = treat(getfield.(results, :lambda))
            mc = RGB(0 / 255, 154 / 255, 250 / 255)
            if size(lambda, 2) > 0
                pl = plot(
                    vpts,
                    lambda;
                    seriestype,
                    mc,
                    ms,
                    label,
                    xlabel = vpt_name[2] * " [" * vpt_name[3] * "]",
                    ylabel = "Wavelength [s]",
                    ylims = (0, Inf),
                    size = (600, 300),
                )
                if format == :html
                    path = joinpath(dir_data, "lambda.html")
                    savefig(pl, path)
                    f = open(path, "r")
                    println(output_f, read(f, String))
                    close(f)
                else
                    display(pl)
                end
            end
        end

        # print instant centre of body 1
        if nvpts == 1
            header = ["No.", "Eigenvalue", "x", "y", "z", "u_x", "u_y", "u_z"]
            temp = my_round.([results[1].mode_vals (results[1].centre[1:6, 1:end])'])
            if format == :html
                println(output_f, "<h2>Rotation centres of first body for all modes</h2>")
                str = pretty_table(String, [1:1:size(temp, 1) temp]; header, backend = :html, standalone = false)
                println(output_f, str)
    
                path = joinpath(dir_data, "centres.html")
                temp = open(path, "w")
                println(temp, str_open, str, str_close)
                close(temp)
            else
                println("Rotation centres of first body for all modes:")
                pretty_table([1:1:size(temp, 1) temp]; header)
            end
        end
    end

    t = unique(abs.(s))
    t = t[t .> 0.1]
    low = floor(log10(0.5 * minimum(t) / 2 / pi))
    low < -2 && (low =-2.0)
    # lowest low eigenvalue, round number in Hz
    high = ceil(log10(2.0 * maximum(t) / 2 / pi))
    # highest high eigenvalue, round number in Hz
    high > 3 && (high = 3.0)

    # if there are too many inputs and outputs, skip
    if nin * nout > 0 && length(bode) > 0 && nin * nout < 16
        # pick out up to four representative vpts from the list
        l = unique(Int.(round.((nvpts - 1) .* [1, 3, 5, 7] / 8 .+ 1)))
        if length(l) == 1
            for i in 1:nin
                # fill in for each selected vpt
                r = findall(bode[:, i] .== 1)
                w = results[l[1]].w / 2 / pi
                mag = cat(results[l[1]].mag..., dims = 3)[r, i, :]
                mag[findall(mag .> 100)] .= Inf
                phs = cat(results[l[1]].phase..., dims = 3)[r, i, :]
                phs[phs.>0] .-= 360
                phs[findall(diff(phs, dims = 2) .> 300)] .= Inf
                phs[findall(diff(phs, dims = 2) .< -300)] .= Inf
                label = hcat(output_names[r]...)
                label .*= "/" * input_names[i]
                xscale = :log10
                p1 = plot(
                    w,
                    mag';
                    lw = 2,
                    label,
                    xlabel = "",
                    ylabel = "Gain [dB]",
                    xscale,
                    xlims = (10^low, 10^high),
                    ylims = (-40, Inf),
                    bottom_margin = 5mm,
                )
                p2 = plot(
                    w,
                    phs';
                    lw = 2,
                    label = "",
                    xlabel = "Frequency [Hz]",
                    ylabel = "Phase [deg]",
                    xscale,
                    xlims = (10^low, 10^high),
                    ylims = (-360, 0),
                    yticks = -360:60:0,
                )
                # merge two subplots
                p = plot(
                    p1,
                    p2,
                    layout = grid(2, 1, heights = [0.66, 0.33]),
                    size = (600, 450),
                )
                if format == :html
                    println(output_f, "<h2>Bode plots</h2>")
                    path = joinpath(dir_data, "bode_$i.html")
                    savefig(p, path)
                    f = open(path, "r")
                    println(output_f, read(f, String))
                    close(f)
                else
                    display(p)
                end
            end
        else
            # loop over outputs and inputs and selected vpts
            for i in 1:nout
                for j in 1:nin
                    if bode[i,j] == 1
                        # make empty plots of magnitude and phase
                        xscale = :log10
                        w = results[l[1]].w / 2 / pi
                        ylabel = "|$(output_names[i])|/|$(input_names[j])| [dB]"
                        p1 = plot(; xlabel = "", ylabel, xscale, xlims = (10^low, 10^high), ylims = (-40, Inf), bottom_margin = 5mm)
                        ylabel = "∠ $(output_names[i])/$(input_names[j]) [deg]"
                        p2 = plot(;
                            xlabel = "Frequency [Hz]",
                            ylabel,
                            xscale,
                            xlims = (10^low, 10^high),
                            ylims = (-360, 0),
                            yticks = -360:60:0,
                        )
                        # fill in for each selected vpt
                        for k in l
                            w = results[k].w / 2 / pi
                            mag = cat(results[k].mag..., dims = 3)[i, j, :]
                            mag[findall(mag .> 100)] .= Inf
                            phs = cat(results[k].phase..., dims = 3)[i, j, :]
                            phs[phs.>0] .-= 360
                            # set wrap arounds in phase to Inf to avoid jumps in plot
                            phs[findall(abs.(diff(phs)) .> 180)] .= Inf
                            if length(l) == 1
                                lb = ""
                            else
                                lb = vpt_name[1] * "=$(my_round(vpts[k])) " * vpt_name[3]
                            end
                            p1 = plot!(p1, w, mag, lw = 2, label = lb)
                            p2 = plot!(p2, w, phs, lw = 2, label = "")
                        end
                        # merge two subplots
                        p = plot(
                            p1,
                            p2,
                            layout = grid(2, 1, heights = [0.66, 0.33]),
                            size = (600, 450),
                        )
                        if format == :html
                            println(output_f, "<h2>Bode plots</h2>")
                            path = joinpath(dir_data, "bode_$(i)_$(j).html")
                            savefig(p, path)
                            f = open(path, "r")
                            println(output_f, read(f, String))
                            close(f)
                        else
                            display(p)
                        end
                    end
                end
            end
        end
    end

    j = 0
    for i in plots
        j += 1
        if format == :html
            println(output_f, "<h2>Time history and other plots</h2>")
            path = joinpath(dir_data, "plot_$j.html")
            savefig(i, path)
            f = open(path, "r")
            println(output_f, read(f, String))
            close(f)
        else
            display(i)
        end
    end

    # add the static preloads
    header = ["Connector", "f_x", "f_y", "f_z", "m_x", "m_y", "m_z"]
    items = [
        systems[1].rigid_points
        systems[1].flex_points
        systems[1].springs
        systems[1].links
    ]
    temp =
        [getfield.(items, :name) my_round.(vcat(getfield.(items, :force)'...); lim = 1e-4) my_round.(
            vcat(getfield.(items, :moment)'...);
            lim = 1e-4,
        )]

    #=    for item in the_system.beams
           println(preload_f, "{$idx} {" * item.name * "} shear $(item.force[1][1]), $(item.force[1][2]), $(item.force[1][3]), $(norm(force[1]))")
           println(preload_f, "{} {} moment $(item.moment[1][1]), $(item.moment[1][2]), $(item.moment[1][3]), $(norm(item.moment[1]))")
           println(preload_f, "{} {} shear $(item.force[2][1]), $(item.force[2][2]), $(item.force[2][3]), $(norm(item.force[2]))")
           println(preload_f, "{} {} moment $(item.moment[2][1]), $(item.moment[2][2]), $(item.moment[2][3]), $(norm(item.moment[2]))")
           idx += 1
       end =#

    if format == :html
        println(output_f, "<h2>Preloads of first system</h2>")
        str = pretty_table(String, temp; header, backend = :html, standalone = false)
        println(output_f, str)

        path = joinpath(dir_data, "preloads.html")
        temp = open(path, "w")
        println(temp, str_open, str, str_close)
        close(temp)
        # print the end and close the output
        println(output_f, str_close)
        close(output_f)

    else
        println("Preloads of first system:")
        pretty_table(temp; header)
    end
end


#   xticks = 10.0 .^ collect(Int(round(log10(w[1]))):1:Int(round(log10(w[end]))))

# function html_table(mtx)
#     # function to put array into html format
#     n, m = size(mtx)

#     str = "<table><thead>\n<tr>"
#     for i in mtx[1, :]
#         str *= "<th>$i</th>"
#     end
#     str *= "</tr>\n</thead><tbody>\n"
#     for i in 2:n
#         str *= "<tr>"
#         for j in mtx[i, :]
#             if j isa String || imag(j) != 0
#                 str *= "<td>$j</td>"
#             else
#                 str *= "<td>$(real(j))</td>"
#             end
#         end
#         str *= "</tr>\n"
#     end
#     str *= "</tbody></table>"
#     str
# end