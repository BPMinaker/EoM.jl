using Plots

function write_html(systems,results,dirs,plots...;filename="result",ss=[0],bode=[0],verbose=false)
## Copyright (C) 2020, Bruce Minaker
## write_md.jl is free software; you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2, or (at your option)
## any later version.
##
## write_md.jl is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details at www.gnu.org/copyleft/gpl.html.
##
##--------------------------------------------------------------------

plotly()

verbose && println("Writing output...")
# set up the paths
dir_date=dirs[1]
dir_time=dirs[2]
dir_data=joinpath(dir_date,dir_time)

# default html start and end text
str_open="<!doctype html>
<html lang=\"en\" >
<head>
    <title>EoM Analysis results</title>
    <meta charset=\"utf-8\">
    <meta name=\"description\" content=\"EoM Analysis result\">
    <meta name=\"author\" content=\"automatically generated by EoM\">
    <style>
    table {
      border-collapse: collapse;
      width: 75%;
    }
    td, th {
      border: 1px solid #dddddd;
      text-align: center;
      padding: 8px;
    }
    tr:nth-child(even) {
      background-color: #dddddd;
    }
    </style>
</head>
<body>
"
str_close="
</body>
</html>
"

# get names of inputs and outputs
input_names=EoM.name.(systems[1].actuators)
output_names=EoM.name.(systems[1].sensors)

# get number of ins, outs, and number of vpts (velocity points)
nin=length(input_names)
nout=length(output_names)
nvpts=length(results)

# open the base html file to write, and start filling it
output_f=open(joinpath(dir_date,filename*".html"),"w")
println(output_f,str_open)
println(output_f,"<h1>EoM Analysis results</h1>")
println(output_f,"<p>Here are the results of the analysis of: $(systems[1].name)</p>")

# start eigenvalues
println(output_f,"<h2>Eigenvalues</h2>")
# get vpts
v=vpt.(systems)
# get eigenvalues, break into real and imaginary
s=hcat(e_val.(results)...)
sr=real.(s)
si=imag(s)
# don't plot exactly zeros, as real roots have lots of zero imaginary parts
sr[sr .==0] .=NaN
si[si .==0] .=NaN

# for one velocity, chart of calcs from eigenvalues, otherwise plot eigenvalues
if nvpts==1
	a=hcat(omega_n.(results)...)
	b=hcat(zeta.(results)...)
	c=hcat(tau.(results)...)
	d=hcat(lambda.(results)...)
	title=["No." "ω_n [Hz]" "ζ" "τ [s]" "λ [s]"]
	values=[a b c d]
	println(output_f,html_table([title;1:1:length(a) round.(values,digits=6)]))
	println(output_f,"<h2>Rotation centres of first body</h2>")

	temp=round.([results[1].mode_vals (results[1].centre[1:6,1:end])'],digits=6)
	println(output_f,html_table( [["Eigenvalue" "x" "y" "z" "u_x" "u_y" "u_z"];temp]))
else
	p=plot(xlabel="Speed [m/s]",ylabel="Eigenvalue [1/s]",size=(600,300))
	plot!(p,v,sr'[:,1],seriestype=:scatter,label="Real")
	plot!(p,v,si'[:,1],seriestype=:scatter,label="Imaginary")
	plot!(p,v,sr',seriestype=:scatter,mc=RGB(0/255,154/255,250/255),label="")
	plot!(p,v,si',seriestype=:scatter,mc=RGB(227/255,111/255,71/255),label="")
	# save the figure
	path=joinpath(dir_data,"eigen.html")
	savefig(p,path)
	# write the link to the figure into the main file
	path=joinpath(dir_time,"eigen.html")
	println(output_f,"<iframe src=\"$path\" width=625 height=325 frameborder=0 ></iframe>")
	println(output_f,"")
end

# if there are too many inputs and outputs, skip
if(nin*nout>0 && nin*nout<16)
	println(output_f,"<h2>Steady state gains</h2>")
	labels=[]
	gain=[]
	# loop over outputs and inputs and vpts
	for i=1:nout
		for j=1:nin
			n=(i-1)*nin+j
			if findnext(ss .==n,1) == nothing
				x=zeros(nvpts)
				for k=1:nvpts
					x[k]=results[k].ss_resp[i,j]
				end
				push!(gain,x[1])
				lb="$(output_names[i])/$(input_names[j])"
				push!(labels,lb)
				# if many vpts, make a plot vs velocity
				if nvpts>1
					p=plot(v,x,lw=2,xlabel="Speed [m/s]",ylabel=lb,label="",size=(600,300))
					# save the figure
					path=joinpath(dir_data,"sstf_$(i)_$(j).html")
					savefig(p,path)
					# write the link to the figure into the main file
					path=joinpath(dir_time,"sstf_$(i)_$(j).html")
					println(output_f,"<iframe src=\"$path\" width=625 height=325 frameborder=0 ></iframe>")
					println(output_f,"")
				end
			end
		end
	end
	# if only one vpt, make a table of the gains
	if nvpts==1
		println(output_f,html_table(["Labels" "Gain"; labels round.(gain,digits=6)]))
	end

	println(output_f,"<h2>Bode plots</h2>")
	# pick out up to four representative vpts from the list
	l=unique(Int.(round.((nvpts-1).*[1,3,5,7]/8 .+1)))
	if length(l)==1
		for i=1:nin
			if findnext(bode .==i,1) == nothing
				# fill in for each selected vpt
				w=results[l[1]].w/2/pi
				mag=20*log10.(abs.(results[l[1]].freq_resp[:,i,:]).+eps(1.0))
				phs=180/pi*angle.(results[l[1]].freq_resp[:,i,:])
				# set wrap arounds in phase to Inf to avoid jumps in plot
				phs[findall(abs.(diff(phs,dims=2)).>180)].=Inf
				lb=hcat(output_names...)
				lb.*="/"*input_names[i]
				p1=plot(w,mag',lw=2,label=lb,xlabel="",ylabel="Gain [dB]",xscale=:log10,ylims=(-60,Inf))
				p2=plot(w,phs',lw=2,label="",xlabel="Frequency [Hz]",ylabel="Phase [deg]",xscale=:log10,ylims=(-180,180),yticks=-180:60:180)
				# merge two subplots
				p=plot(p1,p2,layout=grid(2,1,heights=[0.66,0.33]),size=(600,450))
				# save the figure
				path=joinpath(dir_data,"bode_$i.html")
				savefig(p,path)
				# write the link to the figure into the main file
				path=joinpath(dir_time,"bode_$i.html")
				println(output_f,"<iframe src=\"$path\" width=625 height=475 frameborder=0></iframe>")
				println(output_f,"")
			end
		end
	else
		# loop pver outputs and inputs and selected vpts
		for i=1:nout
			for j=1:nin
				n=(i-1)*nin+j
				if findnext(bode .==n,1) == nothing
					# make empty plots of magnitude and phase
					p1=plot(xlabel="",ylabel="|$(output_names[i])|/|$(input_names[j])| [dB]",xscale=:log10,legend=:top)
					p2=plot(xlabel="Frequency [Hz]",ylabel="∠ $(output_names[i])/$(input_names[j]) [deg]",xscale=:log10,ylims=(-180,180),yticks=-180:60:180)
					# fill in for each selected vpt
					for k in l
						w=results[k].w/2/pi
						mag=20*log10.(abs.(results[k].freq_resp[i,j,:]).+eps(1.0))
						phs=180/pi*angle.(results[k].freq_resp[i,j,:])
						# set wrap arounds in phase to Inf to avoid jumps in plot
						phs[findall(abs.(diff(phs)).>180)].=Inf
						if length(l)==1
							lb=""
						else
							lb="u=$(v[k]) m/s"
						end
						p1=plot!(p1,w,mag,lw=2,label=lb)
						p2=plot!(p2,w,phs,lw=2,label="")
						# merge two subplots
						p=plot(p1,p2,layout=grid(2,1,heights=[0.66,0.33]),size=(600,450))
					end
					# save the figure
					path=joinpath(dir_data,"bode_$(i)_$(j).html")
					savefig(p,path)
					# write the link to the figure into the main file
					path=joinpath(dir_time,"bode_$(i)_$(j).html")
					println(output_f,"<iframe src=\"$path\" width=625 height=475 frameborder=0></iframe>")
					println(output_f,"")
				end
			end
		end
	end
end

n=length(plots)
if n>0
	println(output_f,"<h2>Time history and other plots</h2>")
end
for i=1:n
# save the figure
	path=joinpath(dir_data,"plot_$(i).html")
	savefig(plots[i],path)
# write the link to the figure into the main file
	path=joinpath(dir_time,"plot_$(i).html")
	println(output_f,"<iframe src=\"$path\" width=625 height=425 frameborder=0></iframe>")
	println(output_f,"")
end

# print the end and close the output
println(output_f,str_close)
close(output_f)

dir_date,dir_time

end

function html_table(mtx)
# function to put array into html format
n,m=size(mtx)

str="<table><thead>\n<tr>"
for i in mtx[1,:]
	str*="<th>$i</th>"
end
str*="</tr>\n</thead><tbody>\n"
for i=2:n
	str*="<tr>"
	for j in mtx[i,:]
		str*="<td>$j</td>"
	end
	str*="</tr>\n"
end
str*="</tbody></table>"
str
end
